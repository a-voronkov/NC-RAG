import base64
import hashlib
import io
import os
import threading
import time
import uuid
from typing import Dict, Optional

from fastapi import FastAPI, File, UploadFile, HTTPException, BackgroundTasks, Form
from fastapi.responses import JSONResponse


class JobRecord:
    def __init__(self, job_id: str, filename: str, content_bytes: bytes, trace_id: Optional[str]):
        self.job_id = job_id
        self.filename = filename
        self.content_bytes = content_bytes
        self.trace_id = trace_id or str(uuid.uuid4())
        self.status = "queued"
        self.created_at = time.time()
        self.finished_at: Optional[float] = None
        self.result: Optional[dict] = None


jobs: Dict[str, JobRecord] = {}

app = FastAPI(title="Mock Parser Service", version="0.1.0")


def generate_job_id(content_bytes: bytes) -> str:
    left = hashlib.md5(content_bytes).hexdigest()
    right = hashlib.sha256(content_bytes).hexdigest()[:32]
    return f"{left}-{right}"


def extract_paragraphs_from_bytes(content_bytes: bytes) -> list[str]:
    try:
        text = content_bytes.decode("utf-8", errors="ignore")
    except Exception:
        text = ""
    normalized = text.replace("\r\n", "\n").replace("\r", "\n")
    blocks = [b.strip() for b in normalized.split("\n\n") if b.strip()]
    if not blocks:
        # Fallback: create a synthetic paragraph if content isn't textual
        blocks = ["This is a mock paragraph generated by the mock parser service."]
    return blocks


def build_result_payload(job: JobRecord) -> dict:
    paragraphs = extract_paragraphs_from_bytes(job.content_bytes)

    qa_pairs = []
    for index, para in enumerate(paragraphs, start=1):
        question = f"What is the main idea of paragraph {index}?"
        answer = para[:280] if len(para) > 280 else para
        qa_pairs.append({"q": question, "a": answer, "paragraph_index": index})

    raw_blocks_b64 = [base64.b64encode(job.content_bytes).decode("ascii")]

    return {
        "job_id": job.job_id,
        "trace_id": job.trace_id,
        "status": "succeeded",
        "parser_version": "mock-1.0.0",
        "filename": job.filename,
        "paragraphs": paragraphs,
        "raw_blocks_b64": raw_blocks_b64,
        "qa": qa_pairs,
    }


def process_job(job_id: str, delay_seconds: float = 1.5) -> None:
    job = jobs.get(job_id)
    if not job:
        return
    job.status = "processing"
    time.sleep(delay_seconds)
    job.result = build_result_payload(job)
    job.status = "succeeded"
    job.finished_at = time.time()


@app.get("/health")
def health() -> dict:
    return {"status": "ok"}


@app.post("/parser/jobs")
async def submit_job(
    background_tasks: BackgroundTasks,
    file: UploadFile = File(...),
    trace_id: Optional[str] = Form(default=None),
):
    content = await file.read()
    if not content:
        raise HTTPException(status_code=400, detail="Empty file")

    job_id = generate_job_id(content)
    # Idempotent: if job already exists for same content, reuse
    if job_id in jobs:
        job = jobs[job_id]
    else:
        job = JobRecord(job_id=job_id, filename=file.filename or "unknown", content_bytes=content, trace_id=trace_id)
        jobs[job_id] = job
        background_tasks.add_task(process_job, job_id)

    return JSONResponse(content={"job_id": job.job_id, "trace_id": job.trace_id})


@app.get("/jobs/{job_id}/status")
def job_status(job_id: str):
    job = jobs.get(job_id)
    if not job:
        raise HTTPException(status_code=404, detail="job not found")
    return {"job_id": job.job_id, "status": job.status, "trace_id": job.trace_id}


@app.get("/jobs/{job_id}/result")
def job_result(job_id: str):
    job = jobs.get(job_id)
    if not job:
        raise HTTPException(status_code=404, detail="job not found")
    if job.status != "succeeded" or not job.result:
        raise HTTPException(status_code=409, detail="job not ready")
    return job.result

